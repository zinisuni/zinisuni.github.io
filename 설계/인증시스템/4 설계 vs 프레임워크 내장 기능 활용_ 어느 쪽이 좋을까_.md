<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# 설계 vs 프레임워크 내장 기능 활용: 어느 쪽이 좋을까?

**결론부터**: 핵심 도메인(테넌시, 권한 모델, 리소스 관계)을 잘 설계해두고, 그 위에 프레임워크가 제공하는 표준 기능을 최대한 활용하는 접근이 가장 효율적이다.

## 1. 도메인 설계의 중요성

- **비즈니스 로직 분리**: 테넌트 식별, 역할·권한 매핑, 리소스 스코프 같은 핵심 개념은 프레임워크에 종속되지 않는 **업무 모델**로 먼저 정의해야 한다.
- **독립 테스트 가능**: 설계가 프레임워크 코드와 강하게 결합되어 있으면, 변경·업그레이드 시 리팩토링 비용이 급증한다.


## 2. 프레임워크 기능 활용의 장점

- **생산성**: Rails의 `acts_as_tenant`, Spring Security, Laravel의 `stancl/tenancy`·`spatie/permission`처럼 검증된 구현체를 쓰면, 멀티테넌시와 RBAC의 기본 골격을 짧은 시간에 갖출 수 있다.
- **보안·성능 최적화**: 커뮤니티에 의해 광범위하게 테스트된 코드이므로, 보안 취약점·성능 이슈가 적다.
- **업데이트·유지보수**: 프레임워크 버전 업 시 매뉴얼로 패치된 최신 기능과 호환성을 유지하기 쉬움.


## 3. 프레임워크 기능에 종속될 때의 위험

- **확장 한계**: 내장 기능이 제공하지 않는 커스텀 정책(예: 고급 ReBAC, ABAC 규칙)까지 기대하면 개발 난이도가 크게 올라간다.
- **미묘한 동작 차이**: 프레임워크마다 멀티테넌시나 권한 로딩 시점, 캐싱 방식이 달라, 복잡한 요구사항에서 예기치 못한 동작이 나올 수 있다.


## 4. 추천 아키텍처 패턴

1. **Core Domain Layer**
    - 순수 객체(엔티티, 밸류 오브젝트)로 테넌시·역할·권한·리소스 모델 정의
    - 외부 의존성(프레임워크, DB) 배제
2. **Application Service Layer**
    - 비즈니스 시나리오(권한 검사, 리소스 생성 등) 구현
    - 인터페이스(예: `TenantResolver`, `PermissionChecker`) 사용
3. **Infrastructure Layer**
    - 프레임워크(ORM, 보안 미들웨어) 어댑터 구현
    - `acts_as_tenant`나 `Spring Security` 같은 기능을 이 계층에서 호출
```text
[Controller/API] → [Application Service]
                    ↓
             [Domain Model ←→ Infrastructure Adapter]
```


## 5. 언제 “직접 구현”할까?

- 표준 기능이 **SPEC**을 완전히 충족하지 못할 때
- 매우 복잡한 ABAC·ReBAC 정책이 필요해 **정책 엔진**(Casbin, OPA) 도입이 유리할 때
- 성능·보안 측면에서 프레임워크 내부 API 수준으로 최적화가 절실할 때


## 6. 실전 팁

- **프로토타입**: 먼저 프레임워크 내장 기능으로 빠르게 MVP를 구현.
- **확장 지점 확보**: `PermissionChecker` 등 인터페이스 추상화를 통해, 나중에 정책 로직을 플러그인처럼 교체하도록 설계.
- **테스트 커버리지**: 도메인 로직과 어댑터 로직을 분리해 단위 테스트를 풍부히 작성.

**결론**:

1) **설계 주도**로 비즈니스 모델을 분리한 뒤,
2) **프레임워크 기능**을 인프라 계층에 어댑터 형태로 적용하고,
3) 필요 시 커스텀 정책 엔진이나 직접 구현으로 보강하는 방식이 가장 바람직하다.
